<div id="lapis" lang="ja">
    <!---------- Header ------------->
    <header>
        <div class="top-container">
            <!-- Show the frequency number -->
            {{FreqSort}}

            <!-- The frequency list -->
            {{#Frequency}}
            <span class="freq-dropdown">
                <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" class="dropdown-arrow-svg"
                    viewBox="0 0 16 16">
                    <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"></path>
                    <path d="M 12.7,6.5 H 3.3 L 8,11 Z"></path>
                </svg>
                <div class="freq-list-container">{{Frequency}}</div>
            </span>
            {{/Frequency}}
        </div>
    </header>

    <main>
        <!-- The first row (vocab box+picture) -->
        <div class="def-header">
            <div class="dh-vocab">
                <div class="vocab">
                    {{#ExpressionFurigana}}{{furigana:ExpressionFurigana}}{{/ExpressionFurigana}}
                    {{^ExpressionFurigana}}{{Expression}}{{/ExpressionFurigana}}
                </div>

                <!-- Reading + Pitch Accent -->
                <div class="info">
                    <div class="pitch">
                        {{#ExpressionFurigana}}{{kana:ExpressionFurigana}}{{/ExpressionFurigana}}
                        {{^ExpressionFurigana}}{{ExpressionReading}}{{/ExpressionFurigana}}
                    </div>

                    <!-- Pitch Accent -->
                    <span id="pitch-tags" class="tags">{{PitchPosition}}</span>
                    <br />
                    <div class="audio-buttons"></div>
                </div>
            </div>

            <!-- Image -->
            {{#Picture}}
            <div class="dh-image">
                <div class="image tappable {{Tags}}">{{Picture}}</div>
            </div>
            {{/Picture}}
        </div>

        <br>
        <div class="sentence">
            {{#Picture}}<div class="image-alt tappable {{Tags}}">{{Picture}}</div>{{/Picture}}
                {{#SentenceFurigana}} {{furigana:SentenceFurigana}} {{/SentenceFurigana}}
                {{^SentenceFurigana}} {{furigana:Sentence}} {{/SentenceFurigana}}
            <div class="audio-buttons-alt"></div>
        </div>

        <!-- The entire definition box -->
        <div class="def-info">First Definition 1/?</div>
        <div class="main-def">
            <div class="edge tappable" id="edge-prev" onclick="changeIndex(-1)"></div>
            <div class="edge tappable" id="edge-next" onclick="changeIndex(1)"></div>
            {{#DefinitionPicture}}
            <div class="def-image tappable">{{DefinitionPicture}}</div>
            {{/DefinitionPicture}}
            <div class="definition">
                {{#SelectionText}}
                <div id="selection" data-display-name="Text Selection">{{SelectionText}}</div>
                {{/SelectionText}}
                {{#MainDefinition}}
                <div id="primary" data-display-name="Primary Definition">{{MainDefinition}}</div>
                {{/MainDefinition}}
                <div id="glossaries" data-display-name="Glossaries">{{Glossary}}</div>
            </div>
        </div>

        <!-- Alternative Sentence Position -->
        <div class="sentence-alt">
            {{#Picture}}<div class="image-alt tappable {{Tags}}">{{Picture}}</div>{{/Picture}}
                {{#SentenceFurigana}} {{furigana:SentenceFurigana}} {{/SentenceFurigana}}
                {{^SentenceFurigana}} {{furigana:Sentence}} {{/SentenceFurigana}}
            <div class="audio-buttons-alt"></div>
        </div>

        <!------- Image modal --------->
        <div class="modal-bg tappable">
            <div class="img-popup"></div>
        </div>

        {{#MiscInfo}}
        <details>
            <summary>Misc. info</summary>
            <div class="misc-info">
                === Details ===
                <br />
                {{MiscInfo}}
            </div>
        </details>
        {{/MiscInfo}}
    </main>

    <!----------- Footer ------------->
    <footer>
        <br>
        <div class="bot-container">
            {{#Tags}}
            <div class="tags-container">
                <div class="tags">{{Tags}}</div>
            </div>
            {{/Tags}}
        </div>
    </footer>
</div>

<!----------- Scripts ------------>
<script>
    // Hack to add multiple buttons without Anki playing them multiple times
    function addAudioButtons() {
        const audioContainers = document.querySelectorAll(".audio-buttons, .audio-buttons-alt");
        audioContainers.forEach(audio => audio.innerHTML = `{{ExpressionAudio}}{{SentenceAudio}}`);
    }

    function getPitchCategories() {
        const validTypes = "(heiban|atamadaka|nakadaka|odaka|kifuku)";
        return [...`{{PitchCategories}}`.matchAll(validTypes)].map(m => m[0]);
    }

    function hasVerbOrAdjEnding() {
        const endings = ["い", "う", "く", "ぐ", "す", "つ", "ぶ", "む", "る"];
        return endings.some(ending => `{{text:Expression}}`.endsWith(ending));
    }

    function getPitchType(word_kana, pitchPosition) {
        if (pitchPosition === 0) return "heiban";
        const pitchCategories = getPitchCategories();
        const kifukuTags = ["adj-i", "v1", "v2", "v4", "v5", "vs-", "vz", "vk", "vn", "vr"];
        let canBeKifuku = pitchCategories.includes("kifuku");
        canBeKifuku ||= kifukuTags.some(tag => `{{PitchCategories}}`.includes(tag));
        if (canBeKifuku || (pitchCategories.length == 0 && hasVerbOrAdjEnding())) {
            return "kifuku";
        } else if (pitchPosition === 1) {
            return "atamadaka";
        } else if (pitchPosition > 1) {
            return removeSmallKana(word_kana).length === pitchPosition ? "odaka" : "nakadaka";
        }
    }

    function handlePitches() {
        const exprKana = `{{kana:ExpressionFurigana}}` || `{{ExpressionReading}}`;
        const fieldText = `{{text:PitchPosition}}`;
        // Pitch numbers not in a n+m pattern
        const pitches = fieldText.match(/(?<!\d\+)\d+(?!\+\d)/g)?.map(Number) || [];

        // NHK dictionary pitches
        const NHKDict = document.querySelector(
            '#glossaries li[data-dictionary=\"NHK日本語発音アクセント新辞典\"]');
        const NHKText = NHKDict?.innerHTML.split("<br><br>")[0];
        const NHKPitches = NHKText?.match(/[あ-ヺ°ー＼]+(・[あ-ヺ°ー＼]+)+(?!【)/g) || [];
        // User added pitches, supports AJT
        const customPitches = fieldText.match(/[あ-ヺ°ー\\＼ꜜ]+(・[あ-ヺ°ー\\＼ꜜ]+)*/g) || [];

        // Dirty single katakana to hiragana conversion
        const toHiragana = (kana) => {
            const codePoint = kana?.codePointAt(0)
            const isKatakana = codePoint >= 0x30A1 && codePoint <= 0x30F6;
            return isKatakana ? String.fromCodePoint(codePoint - 0x60) : kana;
        }

        [...customPitches, ...NHKPitches].filter(pitch => {
            // Normalize nasal notations
            const pitchKana = pitch.replace(/([カキクケコかきくけこ])[\u309A°]/g, 
                (match, p1) => String.fromCodePoint(p1.codePointAt(0) + 0x01))
                // Remove downsteps
                .replace(/[・\\＼ꜜ]/g,"");
            return Array.from(pitchKana).every((kana, index) => {
                const hira = toHiragana(kana);
                const exprHira = toHiragana(exprKana[index]);
                return hira === exprHira || hira === 'ー' && "あえいうお".includes(exprHira);
            })
        })
        .forEach(matchedPitches => {
            const pitchArray = matchedPitches.split("・").map(word => {
                const morae = removeSmallKana(word);
                const position = morae.search(/[\\＼ꜜ]/);
                const moraCount = morae.replace(/[\\＼ꜜ]/g,'').length;
                return {position: position === - 1 ? 0 : position, moraCount: moraCount};
            });
            pitches.push(pitchArray.length === 1 ? pitchArray[0].position : pitchArray);
        });

        const pitchPosition = pitches.find(pitch => !Array.isArray(pitch));
        if (pitchPosition) paintTargetWord(getPitchType(exprKana, pitchPosition));
        if (pitches.length > 0) constructPitch(new Set(pitches));
    }

    // Show the color
    function paintTargetWord(pitchType) {
        const sentences = Array.from(
            document.querySelectorAll(".sentence, .sentence-alt, .definition"),
        );
        for (const sentence of sentences) {
            for (const targetWord of sentence.getElementsByTagName("b")) {
                targetWord.classList.add(pitchType);
            }
        }

        const vocabElement = document.querySelector(".vocab");
        if (vocabElement !== null) {
            vocabElement.classList.add(pitchType);
        }
    }

    // Seperate Tags by space, and show them in their own boxes
    function splitTags() {
        const tagsContainer = document.querySelector(".tags-container");
        if (!tagsContainer) return;
        const tags = `{{Tags}}`.split(" ");
        tagsContainer.innerHTML = tags.map(tag =>`<div class="tags">${tag}</div>`).join('');
    }

    // Useful to determine morae count
    function removeSmallKana(kana) {
        return kana.replace(/[ァィゥェォャュョヮぁぃぅぇぉゃゅょゎ\u3099\u309A°]/g, "");
    }

    function groupMoras(kana) {
        let currentChar = "", nextChar = "";
        const groupedMoras = [];
        const smallKana = new Set("ァィゥェォャュョヮぁぃぅぇぉゃゅょゎ\u3099\u309A°");

        for (let i = 0; i < kana.length; i++) {
            currentChar = kana[i];
            nextChar = i < kana.length - 1 && kana[i + 1];
            if (smallKana.has(nextChar)) {
                groupedMoras.push(currentChar + nextChar);
                i += 1;
            } else {
                groupedMoras.push(currentChar);
            }
        }
        return groupedMoras;
    }

    function constructPitch(pitchPatterns) {
        const kana = `{{kana:ExpressionFurigana}}` || `{{ExpressionReading}}`;
        const morae = groupMoras(kana);
        const pitch = document.querySelector(".pitch");
        const pitchTags = document.querySelector("#pitch-tags");

        const createPitchSpan = (pitchClass, pitchChar) => {
            const pitchSpan = document.createElement("span");
            const charSpan = document.createElement("span");
            const lineSpan = document.createElement("span");

            pitchSpan.classList.add(pitchClass);
            charSpan.classList.add("pitch-char");
            charSpan.innerText = pitchChar;
            lineSpan.classList.add("pitch-line");

            pitchSpan.appendChild(charSpan);
            pitchSpan.appendChild(lineSpan);

            return pitchSpan;
        };

        pitch.innerHTML = "";
        pitchTags.innerHTML = "";
        const pitchList = document.createElement("ul");
        const pitchTagList = document.createElement("ul");

        for (let pitchPattern of pitchPatterns) {
            const pitchTag = document.createElement("li");
            const pitchItem = document.createElement("li");
            pitchItem.classList.add("pitch-item");

            const isCompound = Array.isArray(pitchPattern);
            if(isCompound) {
                // Filters duplicates
                const tag = pitchPattern.map(({position}) => position).join(",");
                if([...pitchTagList.children].some(pitchTag => pitchTag.innerText === tag)) continue;
                pitchTag.innerText = tag;
            } else {
                pitchItem.classList.add(getPitchType(kana, pitchPattern));
                pitchTag.innerText = pitchPattern;
                pitchPattern = [{position: pitchPattern, moraCount: morae.length}];
            }

            let offset = 0;
            for (const {position, moraCount} of pitchPattern) {
                for (let i = 0; i < moraCount; i++) {
                    let moraPitch = "";
                    if (position <= 0) {
                        moraPitch = i === 0 ? "pitch-low" : "pitch-high";
                    } else if (position === 1) {
                        moraPitch = i === 0 ? "pitch-to-drop" : "pitch-low";
                    } else {
                        moraPitch = i === position - 1 ? "pitch-to-drop" :
                            i === 0 || i >= position ? "pitch-low" : "pitch-high";
                    }
                    if (offset + i >= morae.length) continue;
                    pitchItem.appendChild(createPitchSpan(moraPitch, morae[offset + i]));
                }
                offset += moraCount;
            }
            pitchTagList.appendChild(pitchTag);
            pitchList.appendChild(pitchItem);
        }

        pitch.appendChild(pitchList);
        pitchTags.appendChild(pitchTagList);
    }

    // Returns the dictionary content, without the dictionary name.
    function getDictionaryContent(dictionarySelector) {
        const dictionary = document.querySelector(dictionarySelector);
        if (!dictionary) return null;
        const contentInSpan = dictionary.querySelector(":scope > span");
        if (contentInSpan) return contentInSpan;

        const hasDictName = dictionary.querySelector(":scope > i");
        if (!hasDictName) return dictionary;

        let dictionaryCopy = dictionary.cloneNode(true);
        dictName = dictionaryCopy.querySelector(":scope > i");
        dictName.remove();
        return dictionaryCopy;
    }

    function isPrimaryEqualToGloss() {
        const isJPMNConverted = document.querySelector(".definition li[data-details]");
        if (isJPMNConverted) return false;
        // single dict formatting
        const isSingleDict = document.querySelectorAll("#glossaries > div > ol").length === 0;
        if (isSingleDict) {
            const primaryDictName = document.querySelector("#primary > div > i");
            const glossariesDictName = document.querySelector("#glossaries > div > i");
            // Compare dicts names if present
            if (primaryDictName && glossariesDictName) {
                return primaryDictName.textContent === glossariesDictName.textContent;
            }
            // Compare content otherwise
            const primaryDict = getDictionaryContent("#primary > div");
            const glossariesDict = getDictionaryContent("#glossaries > div");
            if (!primaryDict || !glossariesDict ) return false;
            return primaryDict.innerHTML.trim() === glossariesDict.innerHTML.trim();
        }

        // multiple dicts
        const primaryDicts = document.querySelectorAll("#primary li[data-dictionary]");
        const glossariesDicts = document.querySelectorAll("#glossaries li[data-dictionary]");
        return primaryDicts.length === glossariesDicts.length;
    }

    // Removes Unnecessary definitions
    function cleanUpDefinitions() {
        let selection = document.getElementById("selection");
        let primary = document.getElementById("primary");
        let glossaries = document.getElementById("glossaries");
        if (selection && selection.textContent === "") {
            selection.remove();
        }
        if (primary && primary.textContent === "") {
            primary.remove();
            primary = null;
        }
        if (glossaries && glossaries.textContent === "") {
            glossaries.remove();
            glossaries = null;
        }
        else if (primary && glossaries && isPrimaryEqualToGloss()) {
            glossaries.remove();
        }
    }

    // Display definition corresponding to index
    function updateDefDisplay() {
        const definitions = document.querySelectorAll(
            ".main-def > .definition > div"
        );

        let n_defs = definitions.length;
        if (n_defs === 1) definitions[0].classList.remove("hidden");
        if (n_defs <= 1) return;

        let currentIndex = document.head.dataset.defIndex;
        currentIndex = currentIndex % n_defs;
        while (currentIndex < 0) currentIndex += n_defs;

        for (let idx = 0; idx < n_defs; idx++) {
            definitions[idx].classList.add("hidden");
        }
        definitions[currentIndex].classList.remove("hidden");

        const defDisplayName = definitions[currentIndex].dataset.displayName;
        const indexDisplay = document.querySelector(".def-info");
        indexDisplay.style.visibility = "visible";
        indexDisplay.innerText = `${defDisplayName} ${currentIndex + 1}/${n_defs}`;
    }

    function changeIndex(value) {
        // sync index between clicks and arrowkeys
        index = Number(document.head.dataset.defIndex);
        document.head.dataset.defIndex = index + value;
        updateDefDisplay();
    };

    function setUpDefToggle() {
        document.head.dataset.defIndex = 0;
        cleanUpDefinitions();

        // Show the first definition and ensure the index display, if relevant, is visible on initial load
        updateDefDisplay();

        // Since <head> doesn't change through review sessions
        // Adding and checking for this class ensure each card doesn't add its own listener
        if (document.head.classList.contains("has-listener")) return;
        document.addEventListener("keydown", (e) => {
            if (e.key === "ArrowLeft") changeIndex(-1);
            else if (e.key === "ArrowRight") changeIndex(1);
        });

        document.head.classList.add("has-listener");
    }

    // Image lightbox with fade transition similar to JPMN
    function clickImages() {
        const modalBg = document.querySelector(".modal-bg");
        const imgPopup = document.querySelector(".img-popup");
        let images = Array.from(document.querySelectorAll(".image img, .image-alt img, .def-image img"));
        /* Disable image links that were opening in a browser window */
        const glossImageLinks = document.querySelectorAll(".definition a:has(img)");
        glossImageLinks.forEach(link => link.href = "");

        images = [... images, ... glossImageLinks];
        if(images.length < 1) return;
        for (let image of images) {
            image.addEventListener("click", () => {
                const imgPopupContainer = document.createElement("div");
                const imgPopupImg = document.createElement("img");

                imgPopupContainer.classList.add("img-popup-container");
                imgPopupImg.src = image.src || image.querySelector("img").src;
                imgPopupImg.classList.add("img-popup-img");

                if (image.height > image.width) {
                    imgPopupContainer.style.height = "calc(100% - 20px)";
                    imgPopupContainer.style.width = "max-content";
                }

                imgPopup.innerHTML = "";
                imgPopup.appendChild(imgPopupContainer);
                imgPopupContainer.appendChild(imgPopupImg);

                // Force a reflow before adding active classes to ensure transitions work
                void modalBg.offsetWidth;

                // Show the modal background with fade transition
                modalBg.style.display = "block";

                // Force another reflow to ensure the display change takes effect before transition
                void modalBg.offsetWidth;

                modalBg.classList.add("active");
                imgPopupContainer.classList.add("active");
                document.body.classList.add("img-popup");
            });
        }

        modalBg.addEventListener("click", () => {
            // Removes active classes to trigger fade-out transition
            modalBg.classList.remove("active");
            const activeContainer = document.querySelector(".img-popup-container.active");
            if (activeContainer) {
                activeContainer.classList.remove("active");
            }
            setTimeout(() => {
                document.body.classList.remove("img-popup");
                modalBg.style.display = "none";
                imgPopup.innerHTML = "";
            }, 300);
        });
    }

    // Format plaintext comma-separated frequencies into a list
    function formatFrequencyList() {
        const frequency = document.querySelector('.freq-list-container');
        if (!frequency) return;
        const frequencyList = frequency.querySelector('ul');
        // Already a list; nothing to do
        if (frequencyList) return;

        const freqs = frequency.innerText.split(',');
        const freqHtml = `<ul>${freqs.map(freq => `<li>${freq.trim()}</li>`).join('')}</ul>`
        frequency.innerHTML = freqHtml;
    }

    // Sets the height of dhVocab, dhImage, defHeader as a whole
    function setDHHeight() {
        var dhVocab = document.querySelector('.dh-vocab');
        var dhImage = document.querySelector('.dh-image img');
        var defHeader = document.querySelector('.def-header');

        if (dhVocab && dhImage) {
            var dhVocabHeight = dhVocab.offsetHeight;
            dhImage.style.maxHeight = `${dhVocabHeight}px`;
            defHeader.style.maxHeight = `${dhVocabHeight}px`;
        }
    }

    // Hides the dictionaries user selected in MainDefinition in Glossary field, if any
    function hideCorrectDefinition() {
        // Do nothing if css rule already exists
        if (document.querySelector("style#hide-main-def")) return;

        let primaryDicts = document.querySelectorAll("#primary li[data-dictionary]");
        if (primaryDicts.length === 0) return;

        let style = document.createElement('style');
        style.type = 'text/css';
        style.id = "hide-main-def";

        const cssSelector = Array.from(primaryDicts).map((dict) =>
            `#glossaries li[data-dictionary="${dict.dataset.dictionary}"]`
        ).join(", ");
        const cssRules = `${cssSelector} { display:none !important; }`;
        style.appendChild(document.createTextNode(cssRules));

        let defContainer = document.querySelector(".main-def");
        defContainer.appendChild(style);
    }

    // Fixes list numbering when using multiple primary dicts
    function movePrimaryDicts() {
        let primaryDicts = document.querySelectorAll("#primary li[data-dictionary]");
        let firstList = document.querySelector("#primary .yomitan-glossary > ol:has(li[data-dictionary])");
        for (let idx = 1; idx < primaryDicts.length; idx++) {
            firstList.appendChild(primaryDicts[idx]);
        }
    }

    // Read user settings and set them as html attributes
    function userSettings() {
        const styles = getComputedStyle(document.documentElement);
        const miscInfo = document.querySelector("details:has(.misc-info)");
        const lapis = document.getElementById("lapis");
        const options = [
            "--main-picture-position",
            "--sentence-furigana",
            "--sentence-position",
            "--audio-buttons",
            "--nsfw-blur-contained",
            "--open-misc-info",
            "--glossary-separator",
            "--jitendex-format"
        ];
        for (const opt of options) {
            let value = styles.getPropertyValue(opt);
            value = value.replace(/^['"]|['"]$/g,"").trim().toLowerCase();
            lapis.setAttribute("data-" + opt.slice(2), value);
            if (opt === "--open-misc-info" && value === "on" && miscInfo) {
                miscInfo.open = true;
            }
        }
    }

    // Initialize all functions!!!
    function initialize() {
        addAudioButtons();
        userSettings();
        splitTags();
        handlePitches();
        setUpDefToggle();
        clickImages();
        formatFrequencyList();
        setDHHeight();
        hideCorrectDefinition();
        movePrimaryDicts();
    }

    initialize();
</script>
